# Chapter 12 TuplesTuples are immutable and they indexed by integers, They are more likelyto ListsSyntactically, tuple is comma separated values`>>> t = 'a','b','c','d' type(t) <class 'tuple'> `you can use parentheses enclose tuples.### If you want to create a tuple with single element you need to end with a comma separated```>>> a = 'a',>>> type(a) <class 'tuple'> ```another way to create a tuple is built-in function called tuple()```>>> create_tuple = tuple()>>> type(create_tuple)<class 'tuple'>```If the argument is a sequence than result is elements of sequence-----------------------------------------------------------------You can slice the tuple`>>> t = tuple('tuple')``>>> t[1:5]('u', 'p', 'l', 'e')`** But don't forget you cannot modify any element of the tuple **### However, we can replace oen tuples with another one `b = ('A',) + t[1:]``>>> b('A', 'u', 'p', 'l', 'e')`Comparing Tuples are going by one by with the indexes of the sequence, first indices matter.`tuple1 = (0,2,300)tuple2 = (1,2,3)```tuple2 > tuple1 # 1 > 0>> True``## If you wan to swap the values of two variables, you need to to **conventional assignment**```>>> a= 1>>> temp = a>>> a =b>>> b = temp```### You can use the Tuple Assignment>>> a, b = b, aRespectively, variables are assigning the values. If you declare two variables than assign it to two values```>>> email = "ali@cemilcan">>> before, after = email.split('@')>>> before'ali'>>> after'cemilcan'```### With divmod() method you can get quotient and remainder as a tuple return values of````>>>bolum, kalan = divmod(13,3)> > > bolum> > > 4> > > kalan> > > 1````** Another example is min_max(t) method that returns 2 values min(t) and max(t) of the given List## The Gather operation takes elements from many processes and gathers them to one single process.`def printall(*args):    print(args`This function '*' takes any number of variables and gather them to one single process## The Scatter process does the vice versa of gather. If you need to pass tuple for example to divmod() function youwill get an error " Exception: 2 argument got 1" if you pass tuple  with  '*'```>>> t= (7,2)>>> type(t)<class 'tuple'>>>> a = divmod(t)Traceback (most recent call last):  File "<stdin>", line 1, in <module>TypeError: divmod expected 2 arguments, got 1>>> a = divmod(*t)>>> a(3, 1)> > >```## Lists and Tuples zip() is a built in function takes elements from two lists and match them together in the tuple.```>>> t = 'ali`>>> c = [1,2,3]`>>> zip(t,c)<zip object at 0x10ca3f820>`You can use for Loop to iterate through the zip elements.>>> for pair in zip(t,c):...     print(pair)...('a', 1)('l', 2)('i', 3)```Zip object has not index, which means you can't use indices to reach element.For this reason ** we convert zip to list object **```>>> list(zip(t,c))[('a', 1), ('l', 2), ('i', 3)]>>> list(zip(t,c))[0]('a', 1)```You can use Tuple assignment in a for loop to traver a list of tuples with```>>> for a,b in [('c',0),('d',1),('r',2)]:...     print(a, b)... c 0d 1r 2>>> for a,b in [('c',0),('d',1),('r',2)]:...     print(a)... cdrb = [('z',3),('d',1),('x',5)]a= [('c',0),('d',1),('r',2)]```has_match function check the tuples and return the matching one```def has_match(a,b):    for x,c in zip(a,b):        if x == c:             print(x, c)        else:            continue    return False    return sum(x for x in range(number) if x % 3 == 0 or x % 5 == 0)```If you need to traverse the index and element of the sequence, you can use ** enumerate() ** function```for index, element in enumerate('ali'):    print(index, element)0 a1 l2 i```## Dictionaries and TuplesDictionaries have a method called items that returns a sequence of tuples, where each tuple is a key-value pair.```tuple_d  = d.items()>>>dict_items([('a', 0), ('b', 1), ('c', 2), ('d', 3)])## You can get Dictionary from a tuplea= [('c',0),('d',1),('r',2)]new_a  = dict(a)>>{'c': 0, 'd': 1, 'r': 2}## You can use zip and dict functions together to get a dictionary from a sequence deneme = dict(zip('abc', range(3))) # range(3) funtion gives the indexes. >>{'a': 0, 'b': 1, 'c': 2}